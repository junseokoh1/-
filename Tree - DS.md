# DS 책!



### 트리 관련 용어

- 노드(node)
- 간선(edge)
- 루트 노드(root node)
- 단말 노드(terminal node) = 잎사귀 노드(leaf node)
  - 아래로 또 다른 노드가 연결되어 있지 않은 노드
- 내부 노드(internal node) = 비단말 노드(nonterminal node)
  - 단말 노드를 제외한 모든 노드



- 서브 트리(Sub Tree)



### 이진 트리

- 이진 트리(binary tree) 정의
  1. 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다.
  2. 나뉘어진 두 서브 트리도 모두 이진 트리이어야 한다.



- 노드가 위치할 수 있는 곳에 노드가 존재하지 않는다면, 공집합(empty set)노드가 존재하는 것으로 간주한다.



- 포화 이진 트리(Full Binary Tree)
  - 모든 레벨이 꽉 찬 이진 트리
- 완전 이진 트리(Complete Binary Tree)
  - **완전 이진 트리**란 마지막 레벨을 제외한 모든 레벨의 node가 완전히 채워져 있으며 마지막 레벨의 node들은 가능한 한 왼쪽부터 채워져 있는 구조를 말한다. 





### 이진 탐색 트리

- 이진 트리의 일종
- 즉 이진 트리에 **데이터의 저장 규칙**을 추가한 것
- 이진 탐색 트리에는 데이터를 저장하는 규칙이 존재하며 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.
- 데이터 저장 규칙
  1. 이진 탐색 트리의 노드에 저장된 키(key)는 유일하다.
  2. 루트 노드의 키가 왼쪽 서브 투리를 구성하는 어떠한 노드의 키보다 크다.
  3. 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다.
  4. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.





- 단점 : 저장 순서에 따라 탐색의 성능에 큰 차이가 난다.

  --> 이러한 단점을 해결한 규형 잡힌 이진 트리가 나옴

  --> 트리는 노드를 균형 있게 가지는 것이 성능에 유리하기 때문에 기본 트리에서 변형된 B-트리, B+ 트리, R-트	  리, 레드 블랙 트리, AVL 트리 등 다양한 종류의 트리 자료구조가 있습니다.





탐색2는 아직 안함...









# Tree - from 바킹독 사이트



- 트리 : 무방향이면서 사이클이 없는 연결 그래프(Undirected Acyclic Connected Graph)



-  트리 또한 간선과 정점으로 이루어진 자료구조로, 그래프의 특별한 종류임

- 이진 탐색 트리를 다룰 땐 계층적인 구조로서의 트리를 다루었지만 트리의 정의 상으로는 계층과 관계된 것이 없으며, 또 정점이 1개이고 간선이 없는 그래프도 트리임에 유의해야 합니다.



- 성질
  - V개의 정점을 가진 트리는 V-1개의 간선을 가지고 있다.
  - 임의의 두 점을 연결하는 simple path가 유일한 그래프
  - 트리에서는 임의의 노드를 루트로 만들 수 있습니다. 트리에서 루트가 정해지고 나면 루트는 부모가 없고 나머지 모든 노드의 부모가 1개로 고정됩니다. 



- 본적으로 트리는 그래프의 특별한 한 종류이기 때문에 이전 장에서 배운 BFS, DFS 알고리즘을 그대로 적용시킬 수 있습니다.





- #### 여기서 그냥 tree에 대해서 BFS, DFS할 때

  - vector<int> adj[10] 이렇게 함!!!
  - 즉 그냥 그래프에서 구현했던 방법이랑 동일!!!

- #### 이진 트리에 대해서는

  - 그냥 vector<int> adj[10]  에 넣어서 저장을 할 수는 있습니다. 그러나 이렇게 처리를 해버리면 왼쪽 자식과 오른쪽 자식을 구분할 수가 없게 됩니다.
  - 그래서 배열 2개 만들어서 구현...
    - left child, right child 배열 2개...



엄청 자세히 안봄...!







# c++  -> 더 찾아보기!

- C++ STL에서는 tree container를 제공하지 않는다 --> tree를 사용하려는 이유에 따라 tree를 구현하거나 대체할 자료형이 달라짐

  

- Tree를 사용하는 이유

  1. mirror the problem using a tree-like structure
  2. container that has tree like access characteristics
     - [`std::map`](https://en.cppreference.com/w/cpp/container/map) (and [`std::multimap`](https://en.cppreference.com/w/cpp/container/multimap))
     - [`std::set`](https://en.cppreference.com/w/cpp/container/set) (and [`std::multiset`](https://en.cppreference.com/w/cpp/container/multiset))





- map의 자료구조는 "트리(tree)"입니다(정확하게 말하면 트리 자료구조 중의 하나인 "레드-블랙 트리(Red-Black tree)"입니다).
  - 레드 블랙 트리는 자가 균형 이진 탐색 트리로써 삽입과 삭제가 일어나는 경우에 자동으로 그 높이를 작게 유지하는 이진 탐색 트리입니다.
  - 따라서 트리에 n개의 원소가 있을 때 **O****(log n**)의 시간 복잡도로 삽입, 삭제, 검색을 할 수 있다.